# pairs

در این repository سولوشن و تست برای یک مسئله الگوریتمی که در پایین توضیح داده شده، پیاده سازی شده است.

## استایل

در این مخزن، تمام کد های زبان Go با رعایت Code Style ها و Best Practice های زبان گو که در شرکت Uber تدوین شده است پیاده سازی شده. [مستندات Uber](https://github.com/uber-go/guide/blob/master/style.md)

همچنین برای نگارش Git Commit Message ها از [این](https://www.conventionalcommits.org/en/v1.0.0/) مستند استفاده شده است.

## مسئله

برنامه‌ای بنویسید که یک لیست از اعداد طبیعی که مرتب نیستند و یک عدد X را در ورودی بگیرد و سپس در لیست داده شده، تمام زوج اعدادی که جمعشان برابر با X هست را پیدا و چاپ کند.

## ⚠ نکته مهم ⚠

در مسئله ارائه شده، توضیحی درباره این که ورودی حاوی اعداد تکراری خواهد بود یا نه داده نشده و همچنین توضیح این که در مواجهه با اعداد تکراری آیا همه زوج مرتب ها علی رغم تکراری بودن چاپ شود یا فقط یکبار چاپ شود داده نشده لزا در این راه حل، حالت کلی در نظر گرفته شده و تمام زوج اعداد علی رغم تکراری بودن چاپ خواهند شد.

### ورودی

یک لیست از اعداد طبیعی - numbers

یک عدد طبیعی - target

### خروجی

چاپ تمام زوج اعداد موجود در لیست که مجموع آن اعداد برابر با target شده است.

### مثال

#### مثال 1

numbers = [1, 2, 3, 4]

target = 5

output: (2, 3), (1, 4)

#### مثال 2: حالت تکراری

numbers = [1, 1, 1]

target = 2

output = (1, 1), (1, 1), (1, 1)

## راهکار

راهکار1: روش brute-force. در این روش به ازای تک تک عناصر آرایه، یک for زده و وجود زوج برای آن عدد را بررسی میکنیم که این روش پیچیدگی زمانی O(n^2) دارد.

راهکار2: ابتدا لیست داده شده را sort کنیم که این عمل O(nlogn) است. سپس دو متغیر کمکی تعریف کرده که یکی اشاره به عنصر اول و یکی اشاره به عنصر آخر میکند. سپس با بررسی جمع عناصری که این متغیر ها اشاره میکنند و حرکت دادن متغیر ها به سمت هم، تمام زوج اعداد پیدا میشود که این عمل O(n) است که در مجموع O(n) + O(nlogn) = O(nlogn) میشود.

راهکار3 (پیشنهادی): استفاده از ساختمان داده HashTable. در این ساختمان داده عملیات Lookup پیچیدگی زمانی O(1) دارد. در این روش، لیست را پیمایش میکنیم و مکمل عدد فعلی (target-current) را پیدا کرده و وجود آن عدد در HashTable را بررسی میکنیم و اگر وجود داشت، زوج مرتب را چاپ میکنیم که در مجموع این روش پیچدگی زمانی O(n) دارد که از بقیه روش ها بهتر است.

برای هندل کردن مقادیر ورودی duplicate، نیاز به ذخیره تعداد تکرار هر یک از اعداد لیست را در Hash Table داریم.

برای شرایط خاصی که زوج اعداد حالت (x, x) برای مثال (2, 2) دارند، برای تعیین تعداد دفعات چاپ آن زوج اعداد، از فرمول ترکیبیاتی انتخاب 2 از بین تکرار ها استفاده میکنیم.

و برای سایر حالات، از اصل ضرب استفاده میکنیم.

## در صورت این که ورودی اعداد تکراری نداشته باشد

در این repository حالت کلی با handle کردن حالت های تکراری پیاده سازی شده است ولی در صورت این که حالت های تکراری در ورودی نداشته باشیم، استفاده از یک ساختمان داده Set و کد زیر کفایت میکند:

```Go
set := make(map[int]struct{})

var result [][2]int

for _, number := range numbers {
    complement := target - number

    if _, exists := set[complement]; exists {
        result = append(result, [2]int{complement, number})
    }

    set[number] = struct{}{}
}
```

اما در این repository حالت کلی و با در نظر گرفتن حالت های تکراری پیاده سازی شده است.


## ساختار کد

در Go برای تعیین ساختار پروژه ها از مفهوم package استفاده میشود. در این مخزن، یک پوشه به اسم pairs وجود دارد که پیاده سازی پکیج pairs است که در آن یک فایل pairs.go که حاوی پیاده سازی الگوریتم حل کننده مسئله و یک فایل pairs_test.go که حاوی unit test برای تابع الگوریتم است.

همچنین در دنیای Go معمولا entry-point برنامه یعنی تابع و پکیج main در root پروژه قرار میگیرد که در اینجا در فایل main.go در root قرار گرفته است.

## کد قابل تست و ماژولار

برای رعایت اصل Single Responsibility، الگوریتم و منطق اصلی حل کننده مسئله در تابع Find قرار داده شده است که ورودی و خروجی مشخص داشته و این امر نوشتن Unit Test برای آن را سهولت بخشیده است. این تابع با تابع چاپ نتایج جدا شده است چون تابع چاپ صرفا برای نمایش استفاده میشود.

در دنیای Go توابع تست در نامشان پیشوند Test دارند. پس برای نوشتن تابع تست برای تابع Find نام تست میشود TestFind.

## تست

برای پیاده سازی یک Unit Test که منطق و الگوریتم اصلی برنامه را مورد آزمون قرار میدهد، از رویکرد Table Driven Test استفاده شده  که در آن مقادیر expected و مقادیر input داده میشود و خروجی الگوریتم با مقادیر expected مقایسه میشود.

در این تابع تست، سعی شده Test Case هایی که انواع مختلف ورودی را در بر میگیرد مورد آزمون قرار بگیرند.

## مدیریت Error ها

در تابع run در فایل main, برای شرایط مختلف که پتانسیل برخورد ارور دارند، ارور های مخصوص تشکیل شده و return میشود.

در دنیای Go ارور ها نیز مانند سایر مقادیر از توابع return میشوند و صدا زننده توابع مسئول دریافت ارور ها و بررسی وجود آن ها با if هستند به این شکل:

```Go
err := run()
if err != nil {
    
}
```

## اجرای برنامه

### پیشنیاز ها

برای اجرای برنامه و تست ها نیاز به نصب Go در سیستم خود دارید. حداقل ورژن 1.22

در root پروژه اجرا کنید:

```Bash
$ go run .
```

### اجرای تست

در پوشه pairs که حاوی کد تست و منطق است اجرا کنید:

```Bash
$ go test
```

خروجی تست:

```Text
PASS
ok      pairs/pairs     0.002s
```

که نشان میدهد تمام تست کیس ها پاس شده اند.

## نکات دیگر درباره Code Style در Go 

- در گو برای نوشتن Documentation برای پکیج ها و توابع، در خط ماقبل تعریف پکیج یا تابع، با فرمتی که در کد برنامه نشان داده شده اقدام به نوشتن توضیحات میکنند.

- هنگامی که برای ساختار پروژه از پکیج های well-defined استفاده شود، مانند مثال ما که پکیج pairs تعریف شده است، در اسم گذاری توابع، از تکرار اسم پکیج در اسم تابع خودداری میشود. برای مثال FindPairs اسم نامناسب و Find اسم مناسب است زیر در هنگام فراخوانی این تابع همیشه اسم پکیج در کنار تابع قرار میگیرد و به این شکل میشود:

 pairs.Find() 

برای حفظ consistency در فرمت کدها، از ابزار go fmt استفاده میکنیم برای اعمال قوانین فرمت که گو تعیین کرده است.

```Bash
$ go fmt ./...
```